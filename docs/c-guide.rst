.. _quickstart-c-guide:

C Guide
=======

This document will introduce how to use bitproto with C language.

Compile bitproto for C
^^^^^^^^^^^^^^^^^^^^^^

Firstly, run the bitproto compiler to generate code for C:

.. sourcecode:: bash

   $ bitproto c pen.bitproto

Where the `pen.bitproto` is introduced in earlier section :ref:`quickstart-example-bitproto`.

We will find that bitproto generates us two files in current directory:

- `pen_bp.h`: Contains the declarations of structs, macros and api functions etc.
- `pen_bp.c`: Contains the function implementations.

It's recommended to open this two generated files to have a look:

* The ``enum`` in bitproto is mapped to a ``typedef`` type in C, and the enum
  values are mapped to macros. The following code snippet is from `pen_bp.h`:

  .. sourcecode:: c

     typedef uint8_t Color; // 3bit

     #define COLOR_UNKNOWN 0
     #define COLOR_RED 1
     #define COLOR_BLUE 2
     #define COLOR_GREEN 3

* The ``Timestamp`` type in bitproto is mapped to a ``typedef`` in C:

  .. sourcecode:: c

     typedef int64_t Timestamp; // 64bit

* The message ``Pen`` in bitproto is mapped to a ``struct`` in C:

  .. sourcecode:: c

     struct Pen {
         Color color; // 3bit
         Timestamp produced_at; // 64bit
     };

* The compiler also generates three functions, they are the encoder, decoder
  and json formatter.

  .. sourcecode:: c

     int EncodePen(struct Pen *m, unsigned char *s);

     int DecodePen(struct Pen *m, unsigned char *s);

     int JsonPen(struct Pen *m, char *s);



Download bitproto C library
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Bitproto serialization requires a language-specific library to work, the generated
encoder and decoder depends on the bitproto C library underlying.

Download the bitproto library for C language from
`this github link <https://github.com/hit9/bitproto/tree/master/lib/c>`_,
and put them (the `bitproto.c` and `bitproto.h`) to current working directory.

Write code
^^^^^^^^^^

Now, we create a file named ``main.c`` and put the following code in it:

.. sourcecode:: c

   #include "pen_bp.h"
   #include <stdio.h>

   int main() {
     struct Pen p = {.color = COLOR_RED, .produced_at = 1611515729966};
     unsigned char s[BYTES_LENGTH_PEN] = {0};

     // Encode p to buffer s.
     EncodePen(&p, s);

     // Decode buffer s to p1.
     struct Pen p1 = {};
     DecodePen(&p1, s);

     // Format p1 to buffer buf.
     char buf[64] = {0};
     JsonPen(&p1, buf);
     printf("%s", buf);

     return 0;
   }

Let's compile it and run:

.. sourcecode:: bash

   $ cc main.c bitproto.c pen_bp.c -o main
   $ ./main
   {"color":1,"produced_at":1611515729966}

The bitproto compiler always generates these three functions for each bitproto
message.

* ``EncodeX`` is the encoder function generated by bitproto for message `X`,
  it takes the address of the message struct and a target bytes buffer,
  encodes the data of the message into the buffer.
* ``DecodeX`` is the decoder function generated by bitproto for message `X`,
  it takes the address of the target message struct and a source bytes buffer,
  decodes the buffer to the target message.
* ``JsonX`` is the json formatter function generated by bitproto for message `X`,
  it formats the message struct to a large-enough buffer, designed for debugging purpose.

What's more, it's worth mentioning that, bitproto's C library won't do any
dynamic memory allocations, there's no malloc.
