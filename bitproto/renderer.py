"""
bitproto.renderer_base
~~~~~~~~~~~~~~~~~~~~~~~

Renderer base class and utils.
"""

import abc
import os
from typing import Dict, List, Optional, Type as T, Tuple, Union, cast

from bitproto.ast import Proto, Definition, Constant, Alias, Uint, Int, Integer
from bitproto.errors import UnsupportedLanguageToRender, InternalError

RendererClass = T["Renderer"]

BITPROTO_DECLARATION = "Code generated by bitproto. DP NOT EDIT."


def get_renderer_registry() -> Dict[str, Tuple[RendererClass, ...]]:
    """Returns the registry of language strings to renderer classes."""

    from bitproto.renderer_c import RendererC, RendererCHeader
    from bitproto.renderer_go import RendererGo
    from bitproto.renderer_py import RendererPy

    return {
        "c": (RendererC, RendererCHeader),
        "go": (RendererGo,),
        "py": (RendererPy,),
    }


def get_renderer_cls(lang: str) -> Optional[Tuple[RendererClass, ...]]:
    """Get renderer classes by language.
    """
    registry = get_renderer_registry()
    return registry.get(lang, None)


def render(proto: Proto, lang: str, outdir: Optional[str] = None) -> List[str]:
    """Render given `proto` to directory `outdir`.
    Returns the filepath list generated.
    """
    clss = get_renderer_cls(lang)
    if clss is None:
        raise UnsupportedLanguageToRender()

    outs = []
    for renderer_cls in clss:
        renderer = renderer_cls(proto, outdir=outdir)
        outs.append(renderer.render())
    return outs


class Formatter:
    """Generic language specific formatter."""

    def format_literal(self, value: Union[str, bool, int]) -> str:
        if value is True or value is False:
            return self.format_bool_literal(value)
        elif isinstance(value, str):
            return self.format_str_literal(value)
        elif isinstance(value, int):
            return self.format_int_literal(value)

    def nbits_from_integer_type(self, type: Integer) -> int:
        """Get number of bits to occupy for an given integer type in a language.
        Below is a default implementation. Special language may override this.
        """
        nbytes = type.nbytes()
        if nbytes == 1:
            return 8
        elif nbytes == 2:
            return 16
        elif nbytes in (3, 4):
            return 32
        elif nbytes in (5, 6, 7, 8):
            return 64
        return nbytes * 8

    @abc.abstractmethod
    def format_comment(self, content: str) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_bool_literal(self, value: bool) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_str_literal(self, value: str) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_int_literal(self, value: int) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_bool_type(self) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_byte_type(self) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_uint_type(self, t: Uint) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_int_type(self, t: Int) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_enum_type(self) -> str:
        raise NotImplementedError

    @abc.abstractmethod
    def format_message_type(self) -> str:
        raise NotImplementedError


class Block:
    """Renderer block."""

    def __init__(self) -> None:
        self.strings: List[str] = []
        self._formatter: Optional[Formatter] = None

    @property
    def formatter(self) -> Formatter:
        assert self._formatter is not None, InternalError("block._formatter not set")
        return self._formatter

    def set_formatter(self, formatter: Formatter) -> None:
        self._formatter = formatter

    def __str__(self) -> str:
        return "\n".join(self.strings)

    def push(self, line: str) -> None:
        self.strings.append(line)

    def clear(self) -> None:
        self.strings = []

    def collect(self) -> str:
        s = str(self)
        self.clear()
        return s

    @abc.abstractmethod
    def render(self) -> None:
        """Render processor for this block, invoked by Renderer.render()."""
        raise NotImplementedError

    def defer(self) -> None:
        """Defer render processor for this block. invoked by Renderer.render()."""
        raise NotImplementedError


class BlockForDefinition(Block):
    """Block for definition."""

    def __init__(self, definition: Definition, name: Optional[str] = None) -> None:
        super(BlockForDefinition, self).__init__()

        self.definition = definition
        self.definition_name: str = name or definition.name

    @property
    def definition_as_constant(self) -> Constant:
        return cast(Constant, self.definition)

    @property
    def definition_as_alias(self) -> Alias:
        return cast(Alias, self.definition)

    def render_doc(self) -> None:
        for comment in self.definition.comment_block:
            self.push(self.formatter.format_comment(comment.content()))


class Renderer:
    """Base renderer class.

    :param proto: The parsed bitproto instance.
    :param outdir: The directory to write files, defaults to the source
       bitproto's file directory, or cwd.
    """

    def __init__(self, proto: Proto, outdir: Optional[str] = None) -> None:
        self.proto = proto
        self.outdir = outdir or self.get_outdir_default(proto)

        self.out_filename = self.format_out_filename()
        self.out_filepath = os.path.join(self.outdir, self.out_filename)

    def get_outdir_default(self, proto: Proto) -> str:
        """Returns outdir default.
        If the given proto is parsed from a file, then use the its directory.
        Otherwise, use current working directory.
        """
        if proto.filepath:  # Parsing from a file.
            return os.path.dirname(os.path.abspath(proto.filepath))
        return os.getcwd()

    def format_out_filename(self) -> str:
        """Returns the output file's name for given extension.

            >>> format_out_filepath(".go")
            example_bp.go
        """
        out_base_name = self.proto.name
        if self.proto.filepath:
            proto_base_name = os.path.basename(self.proto.filepath)
            out_base_name = os.path.splitext(proto_base_name)[0]  # remove extension
        out_filename = out_base_name + "_bp" + self.file_extension()
        return out_filename

    def render_string(self) -> str:
        """Render current proto to string."""
        blocks = self.blocks()
        strings = []
        formatter = self.formatter()

        # Sets formatter
        for block in blocks:
            block.set_formatter(formatter)

        # Executes `render()`.
        for block in blocks:
            block.render()
            strings.append(block.collect())

        # Executes `defer()`.
        reversed_blocks = blocks[::-1]
        for block in reversed_blocks:
            try:
                block.defer()
                strings.append(block.collect())
            except NotImplementedError:
                pass
        return "\n\n".join(strings)

    def render(self) -> str:
        """Render current proto to file(s).
        Returns the filepath generated.
        """
        content = self.render_string()

        with open(self.out_filepath, "w") as f:
            f.write(content)
        return self.out_filepath

    @abc.abstractmethod
    def blocks(self) -> List[Block]:
        """Returns the blocks to render."""
        raise NotImplementedError

    @abc.abstractmethod
    def file_extension(self) -> str:
        """Returns the file extension to generate.  e.g. ".c"
        """
        raise NotImplementedError

    @abc.abstractmethod
    def formatter(self) -> Formatter:
        raise NotImplementedError
