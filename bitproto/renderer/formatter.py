"""
bitproto.renderer.formatter
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Formatter class base.
"""
from abc import abstractmethod
from typing import Optional, Tuple, Union, Type as T

from bitproto._ast import (
    Alias,
    Array,
    Bool,
    Byte,
    Constant,
    Definition,
    Enum,
    EnumField,
    Int,
    Integer,
    Message,
    Node,
    Proto,
    Scope,
    Type,
    Uint,
    Value,
)


class Formatter:
    """Generic language specific formatter."""

    AHEAD_NOTICE = "Code generated by bitproto. DP NOT EDIT."

    def format_token_location(self, node: Node) -> str:
        """Format the source location mark for given node."""
        return f"@@L{node.lineno}"

    def format_value(self, value: Value) -> str:
        """Format value to string."""
        if value is True or value is False:
            return self.format_bool_value(value)
        elif isinstance(value, str):
            return self.format_str_value(value)
        elif isinstance(value, int):
            return self.format_int_value(value)

    def nbits_from_integer_type(self, t: Integer) -> int:
        """Get number of bits to occupy for an given integer type in a language.
        Below is a default implementation. Special language may override this.
        """
        nbytes = t.nbytes()
        if nbytes == 1:
            return 8
        elif nbytes == 2:
            return 16
        elif nbytes in (3, 4):
            return 32
        elif nbytes in (5, 6, 7, 8):
            return 64
        return nbytes * 8

    def scopes_with_namespace(self) -> Tuple[T[Scope], ...]:
        """Returns the scope classes that define namespaces in target language.
        For example, struct in C language defines a namespace, but enum dosen't.
        For languages currently supported, the default implementation kicks enum out
        from this list. Subclasses could override.
        """
        return (Message, Proto)

    def format_definition_name(self, d: Definition) -> str:
        """Formats the declaration name for given definition in target language.
        Target languages may disallow nested declarations (such as structs, enums,
        constants, typedefs).
        Example output format: "Scope1_Scope2_{definition_name}".

        This is a default implementation, subclass may override this.
        """
        if len(d.scope_stack) == 0:
            return d.name  # Current bitproto.

        scope = d.scope_stack[-1]
        definition_name = scope.get_name_by_member(d) or d.name

        classes_ = self.scopes_with_namespace()
        namespaces = [scope for scope in d.scope_stack if isinstance(d, classes_)]

        if len(namespaces) <= 1:
            return definition_name

        namespace = namespaces[-1]

        if isinstance(namespace, Proto):  # Cross proto
            if not self.support_import():
                return definition_name
            items = [self.format_definition_name(namespace), definition_name]
            return self.delimer_cross_proto().join(items)
        else:
            items = [self.format_definition_name(namespace), definition_name]
            return self.delimer_inner_proto().join(items)

    def format_enum_name(self, t: Enum) -> str:
        """Formats the declaration name of given enum,
        with nested-declaration concern."""
        return self.format_definition_name(t)

    def format_message_name(self, t: Message) -> str:
        """Formats the declaration name of given message,
        with nested-declaration concern."""
        return self.format_definition_name(t)

    def format_alias_name(self, t: Alias) -> str:
        """Formats the declaration name of given alias,
        with nested-declaration concern."""
        return self.format_definition_name(t)

    def format_constant_name(self, v: Constant) -> str:
        """Formats the declaration name of given constant,
        with nested-declaration concern."""
        return self.format_definition_name(v)

    def format_enum_field_name(self, f: EnumField) -> str:
        """Formats the declaration name of given enum field,
        with nested-declaration concern."""
        return self.format_definition_name(f)

    def format_type(self, t: Type) -> str:
        """Formats the string representation for given type.
        This is a default implementation.
        """
        if isinstance(t, Bool):
            return self.format_bool_type()
        elif isinstance(t, Byte):
            return self.format_byte_type()
        elif isinstance(t, Uint):
            return self.format_uint_type(t)
        elif isinstance(t, Int):
            return self.format_int_type(t)
        elif isinstance(t, Array):
            return self.format_array_type(t)
        elif isinstance(t, Enum):
            return self.format_enum_type(t)
        elif isinstance(t, Message):
            return self.format_message_type(t)
        elif isinstance(t, Alias):
            return self.format_alias_type(t)
        return "_unknown_type"

    def format_left_shift(self, n: int) -> str:
        return f"<< {n}"

    def format_right_shift(self, n: int) -> str:
        return f">> {n}"

    @abstractmethod
    def ident_character(self) -> str:
        """Ident character of target language, e.g. ' ', '\t'
        """
        raise NotImplementedError

    @abstractmethod
    def support_import(self) -> bool:
        """Dose target language support proto import?"""
        raise NotImplementedError

    @abstractmethod
    def delimer_cross_proto(self) -> str:
        """Delimer character between definitions across protos, e.g. '.'
        """
        raise NotImplementedError

    @abstractmethod
    def delimer_inner_proto(self) -> str:
        """Delimer character between definitions inner a single proto, e.g. '_'
        """
        raise NotImplementedError

    @abstractmethod
    def format_comment(self, content: str) -> str:
        """Format given content into a line of comment in target language."""
        raise NotImplementedError

    @abstractmethod
    def format_bool_value(self, value: bool) -> str:
        """Boolean literal representation in target language."""
        raise NotImplementedError

    @abstractmethod
    def format_str_value(self, value: str) -> str:
        """String literal representation in target language."""
        raise NotImplementedError

    @abstractmethod
    def format_int_value(self, value: int) -> str:
        """Integer literal representation in target language."""
        raise NotImplementedError

    @abstractmethod
    def format_bool_type(self) -> str:
        """Bool type representation in target language."""
        raise NotImplementedError

    @abstractmethod
    def format_byte_type(self) -> str:
        """Byte type representation in target language."""
        raise NotImplementedError

    @abstractmethod
    def format_uint_type(self, t: Uint) -> str:
        """Unsigned integer type representation in target language."""
        raise NotImplementedError

    @abstractmethod
    def format_int_type(self, t: Int) -> str:
        """Signed integer type representation in target language."""
        raise NotImplementedError

    @abstractmethod
    def format_array_type(self, t: Array, name: Optional[str] = None) -> str:
        """Array type representation in target language.
        :param name: Target language (like C) may require a name for array declaration.
        """
        raise NotImplementedError

    def format_enum_type(self, t: Enum) -> str:
        """Enum type representation in target language.
        Normally the enum name, without extra declaration statements."""
        return self.format_definition_name(t)

    def format_message_type(self, t: Message) -> str:
        """Message type representation in target language.
        Normally the message name, without extra declaration statements."""
        return self.format_message_name(t)

    def format_alias_type(self, t: Alias) -> str:
        """Alias type representation in target language.
        Normally the alias name, without extra declaration statements."""
        return self.format_alias_name(t)

    @abstractmethod
    def format_import_statement(self, t: Proto, as_name: Optional[str] = None) -> str:
        raise NotImplementedError
