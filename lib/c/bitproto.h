// Copyright (c) 2021, hit9. https://github.com/hit9/bitproto
// Encoding library for bitproto in C language.

#ifndef __BITPROTO_LIB_H__
#define __BITPROTO_LIB_H__

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#if defined(__cplusplus)
extern "C" {
#endif

#define BP_TYPE_BOOL 1
#define BP_TYPE_INT 2
#define BP_TYPE_UINT 3
#define BP_TYPE_BYTE 4
#define BP_TYPE_ENUM 5
#define BP_TYPE_ALIAS 6
#define BP_TYPE_ARRAY 7
#define BP_TYPE_MESSAGE 8

////////////////////
// Data Abstractions
////////////////////

// BpProcessorContext is the general encoding and decoding context, as an
// argument of processor functions.
struct BpProcessorContext {
    // Indicates whether current processing is encoding or decoding.
    bool is_encode;
    // Tracks the total bits processed.
    int i;
    // Bytes buffer processing. It's the destination buffer under encoding
    // context, and source buffer under decoding context.
    unsigned char *s;
};

// BpProcessor function first constructs its own descriptor, and then continues
// the encoding and decoding processing with given context.
// BpProcessor functions will be generated by bitproto compiler.
typedef void (*BpProcessor)(void *data, struct BpProcessorContext *ctx);

// BpType is an abstraction for all bitproto types.
struct BpType {
    // Flag of this type.
    int flag;
    // Number of bits this type occupy in encoding.
    size_t nbits;
    // Number of bytes this type occupy in memory.
    size_t size;

    // Processor function for this type.
    // Sets if this type is message, enum, alias or array, otherwise NULL.
    BpProcessor processor;
};

// BpAliasDescriptor describes an alias definition.
struct BpAliasDescriptor {
    // The type alias to.
    struct BpType to;
};

// BpEnumDescriptor describes an enum definition.
struct BpEnumDescriptor {
    // Whether this enum is extensible.
    bool extensible;
    // The corresponding uint type.
    struct BpType uint;
};

// BpArrayDescriptor describes an array type.
struct BpArrayDescriptor {
    // Whether this array is extensible.
    bool extensible;
    // Capacity of this array.
    size_t cap;
    // The array element's type.
    struct BpType element_type;
};

// BpMessageFieldDescriptor describes a message field.
struct BpMessageFieldDescriptor {
    // The address of this field's data.
    void *data;
    // Type of this field.
    struct BpType type;
};

// BpMessageDescriptor describes a message.
struct BpMessageDescriptor {
    // Whether this message is extensible.
    bool extensible;
    // Number of fields this message contains.
    int nfields;
    // List of descriptors of the message fields.
    struct BpMessageFieldDescriptor *field_descriptors;
};

////////////////
// Declarations
////////////////

// BpType Constructors.

struct BpType Bool();
struct BpType BpInt(size_t nbits);
struct BpType BpUint(size_t nbits);
struct BpType BpByte();
struct BpType BpMessage(size_t nbits, size_t size, BpProcessor processor);
struct BpType BpEnum(size_t nbits, size_t size, BpProcessor processor);
struct BpType BpArray(size_t nbits, size_t size, BpProcessor processor);
struct BpType BpAlias(size_t nbits, size_t size, BpProcessor processor);

// Descriptor Constructors.

struct BpMessageDescriptor BpMessageDescriptor(
    bool extensible, int nfields,
    struct BpMessageFieldDescriptor *field_descriptors);
struct BpEnumDescriptor BpEnumDescriptor(bool extensible, struct BpType uint);
struct BpArrayDescriptor BpArrayDescriptor(bool extensible, size_t cap,
                                           struct BpType element_type);
struct BpAliasDescriptor BpAliasDescriptor(struct BpType to);

// Encoding & Decoding

void BpEndecodeBaseType(struct BpType type, struct BpProcessorContext *ctx,
                        void *data);
void BpEndecodeMessageField(struct BpMessageFieldDescriptor *descriptor,
                            struct BpProcessorContext *ctx, void *data);
void BpEndecodeMessage(struct BpMessageDescriptor *descriptor,
                       struct BpProcessorContext *ctx, void *data);
void BpEndecodeAlias(struct BpAliasDescriptor *descriptor,
                     struct BpProcessorContext *ctx, void *data);
void BpEndecodeEnum(struct BpEnumDescriptor *descriptor,
                    struct BpProcessorContext *ctx, void *data);
void BpEndecodeArray(struct BpArrayDescriptor *descriptor,
                     struct BpProcessorContext *ctx, void *data);

// Utils

size_t BpIntSizeFromNbits(size_t nbits);
size_t BpUintSizeFromNbits(size_t nbits);
int BpSmartShift(int n, int k);
int BpGetMask(int k, int c);
int BpGetNbitsToCopy(int i, int j, int n);

///////////////////
// Implementations
///////////////////

// BpBool returns a bool BpType.
struct BpType BpBool() {
    return (struct BpType){BP_TYPE_BOOL, 1, sizeof(bool), NULL};
}

// BpInt returns a int BpType for given nbits.
struct BpType BpInt(size_t nbits) {
    return (struct BpType){BP_TYPE_INT, nbits, BpIntSizeFromNbits(nbits), NULL};
}

// BpUint returns a uint BpType for given nbits.
struct BpType BpUint(size_t nbits) {
    return (struct BpType){BP_TYPE_UINT, nbits, BpUintSizeFromNbits(nbits),
                           NULL};
}

// BpByte returns a byte BpType for given nbits.
struct BpType BpByte() {
    return (struct BpType){BP_TYPE_BYTE, 8, sizeof(unsigned char), NULL};
}

// BpMessage returns a message BpType.
struct BpType BpMessage(size_t nbits, size_t size, BpProcessor processor) {
    return (struct BpType){BP_TYPE_MESSAGE, nbits, size, processor};
}

// BpEnum returns an enum BpType.
struct BpType BpEnum(size_t nbits, size_t size, BpProcessor processor) {
    return (struct BpType){BP_TYPE_ENUM, nbits, size, processor};
}

// BpArray returns an array BpType.
struct BpType BpArray(size_t nbits, size_t size, BpProcessor processor) {
    return (struct BpType){BP_TYPE_ARRAY, nbits, size, processor};
}

// BpAlias returns an alias BpType.
struct BpType BpAlias(size_t nbits, size_t size, BpProcessor processor) {
    return (struct BpType){BP_TYPE_ALIAS, nbits, size, processor};
}

// BpMessageFieldDescriptor returns a descriptor for a message.
struct BpMessageDescriptor BpMessageDescriptor(
    bool extensible, int nfields,
    struct BpMessageFieldDescriptor *field_descriptors) {
    return (struct BpMessageDescriptor){extensible, nfields, field_descriptors};
}

// BpEnumDescriptor returns a descriptor for an enum.
struct BpEnumDescriptor BpEnumDescriptor(bool extensible, struct BpType uint) {
    return (struct BpEnumDescriptor){extensible, uint};
}

// BpArrayDescriptor returns a descriptor for an array.
struct BpArrayDescriptor BpArrayDescriptor(bool extensible, size_t cap,
                                           struct BpType element_type) {
    return (struct BpArrayDescriptor){extensible, cap, element_type};
}

// BpAliasDescriptor returns a descriptor for an alias.
struct BpAliasDescriptor BpAliasDescriptor(struct BpType to) {
    return (struct BpAliasDescriptor){to};
}

void BpEndecodeMessage(struct BpMessageDescriptor *descriptor,
                       struct BpProcessorContext *ctx, void *data) {
    for (int k = 0; k < descriptor->nfields; k++) {
        struct BpMessageFieldDescriptor field_descriptor =
            descriptor->field_descriptors[k];
        BpEndecodeMessageField(&field_descriptor, ctx, NULL);
    }
}

void BpEndecodeMessageField(struct BpMessageFieldDescriptor *descriptor,
                            struct BpProcessorContext *ctx, void *data) {
    switch (descriptor->type.flag) {
        case BP_TYPE_BOOL:
        case BP_TYPE_INT:
        case BP_TYPE_UINT:
        case BP_TYPE_BYTE:
            BpEndecodeBaseType(descriptor->type, ctx, descriptor->data);
            break;
        case BP_TYPE_ENUM:
        case BP_TYPE_ALIAS:
        case BP_TYPE_ARRAY:
        case BP_TYPE_MESSAGE:
            descriptor->type.processor(descriptor->data, ctx);
            break;
    }
}

void BpEndecodeAlias(struct BpAliasDescriptor *descriptor,
                     struct BpProcessorContext *ctx, void *data) {
    switch (descriptor->to.flag) {
        case BP_TYPE_BOOL:
        case BP_TYPE_INT:
        case BP_TYPE_UINT:
        case BP_TYPE_BYTE:
            BpEndecodeBaseType(descriptor->to, ctx, data);
            break;
        case BP_TYPE_ARRAY:
            descriptor->to.processor(data, ctx);
            break;
    }
}

void BpEndecodeEnum(struct BpEnumDescriptor *descriptor,
                    struct BpProcessorContext *ctx, void *data) {
    // TODO: extensible.
    BpEndecodeBaseType(descriptor->uint, ctx, data);
}

void BpEndecodeArray(struct BpArrayDescriptor *descriptor,
                     struct BpProcessorContext *ctx, void *data) {
    for (int k = 0; k < descriptor->cap; k++) {
        void *data_ =
            (void *)((unsigned char *)data + k * descriptor->element_type.size);
        switch (descriptor->element_type.flag) {
            case BP_TYPE_BOOL:
            case BP_TYPE_INT:
            case BP_TYPE_UINT:
            case BP_TYPE_BYTE:
                BpEndecodeBaseType(descriptor->element_type, ctx, data_);
                break;
            case BP_TYPE_ALIAS:
            case BP_TYPE_MESSAGE:
            case BP_TYPE_ENUM:
                descriptor->element_type.processor(data_, ctx);
                break;
        }
    }
}

void BpEndecodeBaseType(struct BpType type, struct BpProcessorContext *ctx,
                        void *data) {}

// BpIntSizeFromNbits returns the size of corresponding integer type for given
// bits number.
size_t BpIntSizeFromNbits(size_t nbits) {
    if (nbits <= 8) {
        return sizeof(int8_t);
    }
    if (nbits <= 16 && nbits > 8) {
        return sizeof(int16_t);
    }
    if (nbits <= 32 && nbits > 16) {
        return sizeof(int32_t);
    }
    if (nbits <= 64 && nbits > 32) {
        return sizeof(int64_t);
    }
    return 0;
}

// BpUintSizeFromNbits returns the size of corresponding unsigned integer type
// for given bits number.
size_t BpUintSizeFromNbits(size_t nbits) {
    if (nbits <= 8) {
        return sizeof(uint8_t);
    }
    if (nbits <= 16 && nbits > 8) {
        return sizeof(uint16_t);
    }
    if (nbits <= 32 && nbits > 16) {
        return sizeof(uint32_t);
    }
    if (nbits <= 64 && nbits > 32) {
        return sizeof(uint64_t);
    }
    return 0;
}

#if defined(__cplusplus)
}
#endif

#endif
